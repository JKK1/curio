// Code generated by github.com/filecoin-project/lotus/gen/api. DO NOT EDIT.

package chainapi

import (
	"context"
	"github.com/filecoin-project/curio/deps/types"
	"github.com/filecoin-project/go-address"
	"github.com/filecoin-project/go-bitfield"
	"github.com/filecoin-project/go-jsonrpc/auth"
	"github.com/filecoin-project/go-state-types/abi"
	minertypes13 "github.com/filecoin-project/go-state-types/builtin/v13/miner"
	minertypes "github.com/filecoin-project/go-state-types/builtin/v9/miner"
	verifregtypes9 "github.com/filecoin-project/go-state-types/builtin/v9/verifreg"
	"github.com/filecoin-project/go-state-types/crypto"
	"github.com/filecoin-project/go-state-types/dline"
	"github.com/filecoin-project/go-state-types/network"
	"github.com/filecoin-project/go-state-types/proof"
	"github.com/filecoin-project/lotus/journal/alerting"
	"github.com/google/uuid"
	"github.com/ipfs/go-cid"
	"github.com/ipfs/go-libipfs/blocks"
	pubsub "github.com/libp2p/go-libp2p-pubsub"
	"github.com/libp2p/go-libp2p/core/metrics"
	p2pnetwork "github.com/libp2p/go-libp2p/core/network"
	"github.com/libp2p/go-libp2p/core/peer"
	"github.com/libp2p/go-libp2p/core/protocol"
	"math/big"
	"time"

)


var ErrNotSupported = xerrors.New("method not supported")


type CommonStruct struct {

	Internal CommonMethods
}

type CommonMethods struct {

	AuthNew func(p0 context.Context, p1 []auth.Permission) ([]byte, error) `perm:"admin"`


	AuthVerify func(p0 context.Context, p1 string) ([]auth.Permission, error) `perm:"read"`


	Closing func(p0 context.Context) (<-chan struct{}, error) `perm:"read"`


	Discover func(p0 context.Context) (OpenRPCDocument, error) `perm:"read"`


	LogAlerts func(p0 context.Context) ([]alerting.Alert, error) `perm:"admin"`


	LogList func(p0 context.Context) ([]string, error) `perm:"write"`


	LogSetLevel func(p0 context.Context, p1 string, p2 string) (error) `perm:"write"`


	Session func(p0 context.Context) (uuid.UUID, error) `perm:"read"`


	Shutdown func(p0 context.Context) (error) `perm:"admin"`


	StartTime func(p0 context.Context) (time.Time, error) `perm:"read"`


	Version func(p0 context.Context) (APIVersion, error) `perm:"read"`


	}

type CommonStub struct {

}

type DaemonStruct struct {

	CommonStruct

	NetStruct

	Internal DaemonMethods
}

type DaemonMethods struct {

	ChainGetMessage func(p0 context.Context, p1 cid.Cid) (*types.Message, error) ``


	ChainGetTipSet func(p0 context.Context, p1 types.TipSetKey) (*types.TipSet, error) ``


	ChainGetTipSetAfterHeight func(p0 context.Context, p1 abi.ChainEpoch, p2 types.TipSetKey) (*types.TipSet, error) ``


	ChainGetTipSetByHeight func(p0 context.Context, p1 abi.ChainEpoch, p2 types.TipSetKey) (*types.TipSet, error) ``


	ChainHasObj func(p0 context.Context, p1 cid.Cid) (bool, error) ``


	ChainHead func(p0 context.Context) (*types.TipSet, error) ``


	ChainNotify func(p0 context.Context) (<-chan []*HeadChange, error) ``


	ChainPutObj func(p0 context.Context, p1 blocks.Block) (error) ``


	ChainReadObj func(p0 context.Context, p1 cid.Cid) ([]byte, error) ``


	ChainTipSetWeight func(p0 context.Context, p1 types.TipSetKey) (types.BigInt, error) ``


	GasEstimateFeeCap func(p0 context.Context, p1 *types.Message, p2 int64, p3 types.TipSetKey) (types.BigInt, error) ``


	GasEstimateGasPremium func(p0 context.Context, p1 uint64, p2 address.Address, p3 int64, p4 types.TipSetKey) (types.BigInt, error) ``


	GasEstimateMessageGas func(p0 context.Context, p1 *types.Message, p2 *MessageSendSpec, p3 types.TipSetKey) (*types.Message, error) ``


	MinerCreateBlock func(p0 context.Context, p1 *BlockTemplate) (*types.BlockMsg, error) ``


	MinerGetBaseInfo func(p0 context.Context, p1 address.Address, p2 abi.ChainEpoch, p3 types.TipSetKey) (*MiningBaseInfo, error) ``


	MpoolGetNonce func(p0 context.Context, p1 address.Address) (uint64, error) ``


	MpoolPush func(p0 context.Context, p1 *types.SignedMessage) (cid.Cid, error) ``


	MpoolPushMessage func(p0 context.Context, p1 *types.Message, p2 *MessageSendSpec) (*types.SignedMessage, error) ``


	MpoolSelect func(p0 context.Context, p1 types.TipSetKey, p2 float64) ([]*types.SignedMessage, error) ``


	StateAccountKey func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (address.Address, error) ``


	StateGetActor func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*types.Actor, error) ``


	StateGetAllocation func(p0 context.Context, p1 address.Address, p2 verifregtypes9.AllocationId, p3 types.TipSetKey) (*verifregtypes9.Allocation, error) ``


	StateGetAllocationForPendingDeal func(p0 context.Context, p1 abi.DealID, p2 types.TipSetKey) (*verifregtypes9.Allocation, error) ``


	StateGetAllocationIdForPendingDeal func(p0 context.Context, p1 abi.DealID, p2 types.TipSetKey) (verifregtypes9.AllocationId, error) ``


	StateGetBeaconEntry func(p0 context.Context, p1 abi.ChainEpoch) (*types.BeaconEntry, error) ``


	StateGetRandomnessFromBeacon func(p0 context.Context, p1 crypto.DomainSeparationTag, p2 abi.ChainEpoch, p3 []byte, p4 types.TipSetKey) (abi.Randomness, error) ``


	StateGetRandomnessFromTickets func(p0 context.Context, p1 crypto.DomainSeparationTag, p2 abi.ChainEpoch, p3 []byte, p4 types.TipSetKey) (abi.Randomness, error) ``


	StateLookupID func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (address.Address, error) ``


	StateMinerActiveSectors func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) ([]*SectorOnChainInfo, error) ``


	StateMinerAllocated func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*bitfield.BitField, error) ``


	StateMinerInfo func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (MinerInfo, error) ``


	StateMinerInitialPledgeCollateral func(p0 context.Context, p1 address.Address, p2 SectorPreCommitInfo, p3 types.TipSetKey) (big.Int, error) ``


	StateMinerPartitions func(p0 context.Context, p1 address.Address, p2 uint64, p3 types.TipSetKey) ([]Partition, error) ``


	StateMinerPreCommitDepositForPower func(p0 context.Context, p1 address.Address, p2 SectorPreCommitInfo, p3 types.TipSetKey) (big.Int, error) ``


	StateMinerProvingDeadline func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*dline.Info, error) ``


	StateMinerSectors func(p0 context.Context, p1 address.Address, p2 *bitfield.BitField, p3 types.TipSetKey) ([]*SectorOnChainInfo, error) ``


	StateNetworkVersion func(p0 context.Context, p1 types.TipSetKey) (network.Version, error) ``


	StateSearchMsg func(p0 context.Context, p1 types.TipSetKey, p2 cid.Cid, p3 abi.ChainEpoch, p4 bool) (*MsgLookup, error) ``


	StateSectorGetInfo func(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 types.TipSetKey) (*SectorOnChainInfo, error) ``


	StateSectorPartition func(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 types.TipSetKey) (*SectorLocation, error) ``


	StateSectorPreCommitInfo func(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 types.TipSetKey) (*SectorPreCommitOnChainInfo, error) ``


	SyncSubmitBlock func(p0 context.Context, p1 *types.BlockMsg) (error) ``


	WalletBalance func(p0 context.Context, p1 address.Address) (big.Int, error) ``


	WalletHas func(p0 context.Context, p1 address.Address) (bool, error) ``


	WalletSign func(p0 context.Context, p1 address.Address, p2 []byte) (*crypto.Signature, error) ``


	WalletSignMessage func(p0 context.Context, p1 address.Address, p2 *types.Message) (*types.SignedMessage, error) ``


	}

type DaemonStub struct {

	CommonStub

	NetStub

}

type NetStruct struct {

	Internal NetMethods
}

type NetMethods struct {

	ID func(p0 context.Context) (peer.ID, error) `perm:"read"`


	NetAddrsListen func(p0 context.Context) (peer.AddrInfo, error) `perm:"read"`


	NetAgentVersion func(p0 context.Context, p1 peer.ID) (string, error) `perm:"read"`


	NetAutoNatStatus func(p0 context.Context) (NatInfo, error) `perm:"read"`


	NetBandwidthStats func(p0 context.Context) (metrics.Stats, error) `perm:"read"`


	NetBandwidthStatsByPeer func(p0 context.Context) (map[string]metrics.Stats, error) `perm:"read"`


	NetBandwidthStatsByProtocol func(p0 context.Context) (map[protocol.ID]metrics.Stats, error) `perm:"read"`


	NetBlockAdd func(p0 context.Context, p1 NetBlockList) (error) `perm:"admin"`


	NetBlockList func(p0 context.Context) (NetBlockList, error) `perm:"read"`


	NetBlockRemove func(p0 context.Context, p1 NetBlockList) (error) `perm:"admin"`


	NetConnect func(p0 context.Context, p1 peer.AddrInfo) (error) `perm:"write"`


	NetConnectedness func(p0 context.Context, p1 peer.ID) (p2pnetwork.Connectedness, error) `perm:"read"`


	NetDisconnect func(p0 context.Context, p1 peer.ID) (error) `perm:"write"`


	NetFindPeer func(p0 context.Context, p1 peer.ID) (peer.AddrInfo, error) `perm:"read"`


	NetLimit func(p0 context.Context, p1 string) (NetLimit, error) `perm:"read"`


	NetPeerInfo func(p0 context.Context, p1 peer.ID) (*ExtendedPeerInfo, error) `perm:"read"`


	NetPeers func(p0 context.Context) ([]peer.AddrInfo, error) `perm:"read"`


	NetPing func(p0 context.Context, p1 peer.ID) (time.Duration, error) `perm:"read"`


	NetProtectAdd func(p0 context.Context, p1 []peer.ID) (error) `perm:"admin"`


	NetProtectList func(p0 context.Context) ([]peer.ID, error) `perm:"read"`


	NetProtectRemove func(p0 context.Context, p1 []peer.ID) (error) `perm:"admin"`


	NetPubsubScores func(p0 context.Context) ([]PubsubScore, error) `perm:"read"`


	NetSetLimit func(p0 context.Context, p1 string, p2 NetLimit) (error) `perm:"admin"`


	NetStat func(p0 context.Context, p1 string) (NetStat, error) `perm:"read"`


	}

type NetStub struct {

}





func (s *CommonStruct) AuthNew(p0 context.Context, p1 []auth.Permission) ([]byte, error) {
	if s.Internal.AuthNew == nil {
		return *new([]byte), ErrNotSupported
	}
	return s.Internal.AuthNew(p0, p1)
}

func (s *CommonStub) AuthNew(p0 context.Context, p1 []auth.Permission) ([]byte, error) {
	return *new([]byte), ErrNotSupported
}

func (s *CommonStruct) AuthVerify(p0 context.Context, p1 string) ([]auth.Permission, error) {
	if s.Internal.AuthVerify == nil {
		return *new([]auth.Permission), ErrNotSupported
	}
	return s.Internal.AuthVerify(p0, p1)
}

func (s *CommonStub) AuthVerify(p0 context.Context, p1 string) ([]auth.Permission, error) {
	return *new([]auth.Permission), ErrNotSupported
}

func (s *CommonStruct) Closing(p0 context.Context) (<-chan struct{}, error) {
	if s.Internal.Closing == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.Closing(p0)
}

func (s *CommonStub) Closing(p0 context.Context) (<-chan struct{}, error) {
	return nil, ErrNotSupported
}

func (s *CommonStruct) Discover(p0 context.Context) (OpenRPCDocument, error) {
	if s.Internal.Discover == nil {
		return *new(OpenRPCDocument), ErrNotSupported
	}
	return s.Internal.Discover(p0)
}

func (s *CommonStub) Discover(p0 context.Context) (OpenRPCDocument, error) {
	return *new(OpenRPCDocument), ErrNotSupported
}

func (s *CommonStruct) LogAlerts(p0 context.Context) ([]alerting.Alert, error) {
	if s.Internal.LogAlerts == nil {
		return *new([]alerting.Alert), ErrNotSupported
	}
	return s.Internal.LogAlerts(p0)
}

func (s *CommonStub) LogAlerts(p0 context.Context) ([]alerting.Alert, error) {
	return *new([]alerting.Alert), ErrNotSupported
}

func (s *CommonStruct) LogList(p0 context.Context) ([]string, error) {
	if s.Internal.LogList == nil {
		return *new([]string), ErrNotSupported
	}
	return s.Internal.LogList(p0)
}

func (s *CommonStub) LogList(p0 context.Context) ([]string, error) {
	return *new([]string), ErrNotSupported
}

func (s *CommonStruct) LogSetLevel(p0 context.Context, p1 string, p2 string) (error) {
	if s.Internal.LogSetLevel == nil {
		return ErrNotSupported
	}
	return s.Internal.LogSetLevel(p0, p1, p2)
}

func (s *CommonStub) LogSetLevel(p0 context.Context, p1 string, p2 string) (error) {
	return ErrNotSupported
}

func (s *CommonStruct) Session(p0 context.Context) (uuid.UUID, error) {
	if s.Internal.Session == nil {
		return *new(uuid.UUID), ErrNotSupported
	}
	return s.Internal.Session(p0)
}

func (s *CommonStub) Session(p0 context.Context) (uuid.UUID, error) {
	return *new(uuid.UUID), ErrNotSupported
}

func (s *CommonStruct) Shutdown(p0 context.Context) (error) {
	if s.Internal.Shutdown == nil {
		return ErrNotSupported
	}
	return s.Internal.Shutdown(p0)
}

func (s *CommonStub) Shutdown(p0 context.Context) (error) {
	return ErrNotSupported
}

func (s *CommonStruct) StartTime(p0 context.Context) (time.Time, error) {
	if s.Internal.StartTime == nil {
		return *new(time.Time), ErrNotSupported
	}
	return s.Internal.StartTime(p0)
}

func (s *CommonStub) StartTime(p0 context.Context) (time.Time, error) {
	return *new(time.Time), ErrNotSupported
}

func (s *CommonStruct) Version(p0 context.Context) (APIVersion, error) {
	if s.Internal.Version == nil {
		return *new(APIVersion), ErrNotSupported
	}
	return s.Internal.Version(p0)
}

func (s *CommonStub) Version(p0 context.Context) (APIVersion, error) {
	return *new(APIVersion), ErrNotSupported
}




func (s *DaemonStruct) ChainGetMessage(p0 context.Context, p1 cid.Cid) (*types.Message, error) {
	if s.Internal.ChainGetMessage == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.ChainGetMessage(p0, p1)
}

func (s *DaemonStub) ChainGetMessage(p0 context.Context, p1 cid.Cid) (*types.Message, error) {
	return nil, ErrNotSupported
}

func (s *DaemonStruct) ChainGetTipSet(p0 context.Context, p1 types.TipSetKey) (*types.TipSet, error) {
	if s.Internal.ChainGetTipSet == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.ChainGetTipSet(p0, p1)
}

func (s *DaemonStub) ChainGetTipSet(p0 context.Context, p1 types.TipSetKey) (*types.TipSet, error) {
	return nil, ErrNotSupported
}

func (s *DaemonStruct) ChainGetTipSetAfterHeight(p0 context.Context, p1 abi.ChainEpoch, p2 types.TipSetKey) (*types.TipSet, error) {
	if s.Internal.ChainGetTipSetAfterHeight == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.ChainGetTipSetAfterHeight(p0, p1, p2)
}

func (s *DaemonStub) ChainGetTipSetAfterHeight(p0 context.Context, p1 abi.ChainEpoch, p2 types.TipSetKey) (*types.TipSet, error) {
	return nil, ErrNotSupported
}

func (s *DaemonStruct) ChainGetTipSetByHeight(p0 context.Context, p1 abi.ChainEpoch, p2 types.TipSetKey) (*types.TipSet, error) {
	if s.Internal.ChainGetTipSetByHeight == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.ChainGetTipSetByHeight(p0, p1, p2)
}

func (s *DaemonStub) ChainGetTipSetByHeight(p0 context.Context, p1 abi.ChainEpoch, p2 types.TipSetKey) (*types.TipSet, error) {
	return nil, ErrNotSupported
}

func (s *DaemonStruct) ChainHasObj(p0 context.Context, p1 cid.Cid) (bool, error) {
	if s.Internal.ChainHasObj == nil {
		return false, ErrNotSupported
	}
	return s.Internal.ChainHasObj(p0, p1)
}

func (s *DaemonStub) ChainHasObj(p0 context.Context, p1 cid.Cid) (bool, error) {
	return false, ErrNotSupported
}

func (s *DaemonStruct) ChainHead(p0 context.Context) (*types.TipSet, error) {
	if s.Internal.ChainHead == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.ChainHead(p0)
}

func (s *DaemonStub) ChainHead(p0 context.Context) (*types.TipSet, error) {
	return nil, ErrNotSupported
}

func (s *DaemonStruct) ChainNotify(p0 context.Context) (<-chan []*HeadChange, error) {
	if s.Internal.ChainNotify == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.ChainNotify(p0)
}

func (s *DaemonStub) ChainNotify(p0 context.Context) (<-chan []*HeadChange, error) {
	return nil, ErrNotSupported
}

func (s *DaemonStruct) ChainPutObj(p0 context.Context, p1 blocks.Block) (error) {
	if s.Internal.ChainPutObj == nil {
		return ErrNotSupported
	}
	return s.Internal.ChainPutObj(p0, p1)
}

func (s *DaemonStub) ChainPutObj(p0 context.Context, p1 blocks.Block) (error) {
	return ErrNotSupported
}

func (s *DaemonStruct) ChainReadObj(p0 context.Context, p1 cid.Cid) ([]byte, error) {
	if s.Internal.ChainReadObj == nil {
		return *new([]byte), ErrNotSupported
	}
	return s.Internal.ChainReadObj(p0, p1)
}

func (s *DaemonStub) ChainReadObj(p0 context.Context, p1 cid.Cid) ([]byte, error) {
	return *new([]byte), ErrNotSupported
}

func (s *DaemonStruct) ChainTipSetWeight(p0 context.Context, p1 types.TipSetKey) (types.BigInt, error) {
	if s.Internal.ChainTipSetWeight == nil {
		return *new(types.BigInt), ErrNotSupported
	}
	return s.Internal.ChainTipSetWeight(p0, p1)
}

func (s *DaemonStub) ChainTipSetWeight(p0 context.Context, p1 types.TipSetKey) (types.BigInt, error) {
	return *new(types.BigInt), ErrNotSupported
}

func (s *DaemonStruct) GasEstimateFeeCap(p0 context.Context, p1 *types.Message, p2 int64, p3 types.TipSetKey) (types.BigInt, error) {
	if s.Internal.GasEstimateFeeCap == nil {
		return *new(types.BigInt), ErrNotSupported
	}
	return s.Internal.GasEstimateFeeCap(p0, p1, p2, p3)
}

func (s *DaemonStub) GasEstimateFeeCap(p0 context.Context, p1 *types.Message, p2 int64, p3 types.TipSetKey) (types.BigInt, error) {
	return *new(types.BigInt), ErrNotSupported
}

func (s *DaemonStruct) GasEstimateGasPremium(p0 context.Context, p1 uint64, p2 address.Address, p3 int64, p4 types.TipSetKey) (types.BigInt, error) {
	if s.Internal.GasEstimateGasPremium == nil {
		return *new(types.BigInt), ErrNotSupported
	}
	return s.Internal.GasEstimateGasPremium(p0, p1, p2, p3, p4)
}

func (s *DaemonStub) GasEstimateGasPremium(p0 context.Context, p1 uint64, p2 address.Address, p3 int64, p4 types.TipSetKey) (types.BigInt, error) {
	return *new(types.BigInt), ErrNotSupported
}

func (s *DaemonStruct) GasEstimateMessageGas(p0 context.Context, p1 *types.Message, p2 *MessageSendSpec, p3 types.TipSetKey) (*types.Message, error) {
	if s.Internal.GasEstimateMessageGas == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.GasEstimateMessageGas(p0, p1, p2, p3)
}

func (s *DaemonStub) GasEstimateMessageGas(p0 context.Context, p1 *types.Message, p2 *MessageSendSpec, p3 types.TipSetKey) (*types.Message, error) {
	return nil, ErrNotSupported
}

func (s *DaemonStruct) MinerCreateBlock(p0 context.Context, p1 *BlockTemplate) (*types.BlockMsg, error) {
	if s.Internal.MinerCreateBlock == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.MinerCreateBlock(p0, p1)
}

func (s *DaemonStub) MinerCreateBlock(p0 context.Context, p1 *BlockTemplate) (*types.BlockMsg, error) {
	return nil, ErrNotSupported
}

func (s *DaemonStruct) MinerGetBaseInfo(p0 context.Context, p1 address.Address, p2 abi.ChainEpoch, p3 types.TipSetKey) (*MiningBaseInfo, error) {
	if s.Internal.MinerGetBaseInfo == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.MinerGetBaseInfo(p0, p1, p2, p3)
}

func (s *DaemonStub) MinerGetBaseInfo(p0 context.Context, p1 address.Address, p2 abi.ChainEpoch, p3 types.TipSetKey) (*MiningBaseInfo, error) {
	return nil, ErrNotSupported
}

func (s *DaemonStruct) MpoolGetNonce(p0 context.Context, p1 address.Address) (uint64, error) {
	if s.Internal.MpoolGetNonce == nil {
		return 0, ErrNotSupported
	}
	return s.Internal.MpoolGetNonce(p0, p1)
}

func (s *DaemonStub) MpoolGetNonce(p0 context.Context, p1 address.Address) (uint64, error) {
	return 0, ErrNotSupported
}

func (s *DaemonStruct) MpoolPush(p0 context.Context, p1 *types.SignedMessage) (cid.Cid, error) {
	if s.Internal.MpoolPush == nil {
		return *new(cid.Cid), ErrNotSupported
	}
	return s.Internal.MpoolPush(p0, p1)
}

func (s *DaemonStub) MpoolPush(p0 context.Context, p1 *types.SignedMessage) (cid.Cid, error) {
	return *new(cid.Cid), ErrNotSupported
}

func (s *DaemonStruct) MpoolPushMessage(p0 context.Context, p1 *types.Message, p2 *MessageSendSpec) (*types.SignedMessage, error) {
	if s.Internal.MpoolPushMessage == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.MpoolPushMessage(p0, p1, p2)
}

func (s *DaemonStub) MpoolPushMessage(p0 context.Context, p1 *types.Message, p2 *MessageSendSpec) (*types.SignedMessage, error) {
	return nil, ErrNotSupported
}

func (s *DaemonStruct) MpoolSelect(p0 context.Context, p1 types.TipSetKey, p2 float64) ([]*types.SignedMessage, error) {
	if s.Internal.MpoolSelect == nil {
		return *new([]*types.SignedMessage), ErrNotSupported
	}
	return s.Internal.MpoolSelect(p0, p1, p2)
}

func (s *DaemonStub) MpoolSelect(p0 context.Context, p1 types.TipSetKey, p2 float64) ([]*types.SignedMessage, error) {
	return *new([]*types.SignedMessage), ErrNotSupported
}

func (s *DaemonStruct) StateAccountKey(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (address.Address, error) {
	if s.Internal.StateAccountKey == nil {
		return *new(address.Address), ErrNotSupported
	}
	return s.Internal.StateAccountKey(p0, p1, p2)
}

func (s *DaemonStub) StateAccountKey(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (address.Address, error) {
	return *new(address.Address), ErrNotSupported
}

func (s *DaemonStruct) StateGetActor(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*types.Actor, error) {
	if s.Internal.StateGetActor == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.StateGetActor(p0, p1, p2)
}

func (s *DaemonStub) StateGetActor(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*types.Actor, error) {
	return nil, ErrNotSupported
}

func (s *DaemonStruct) StateGetAllocation(p0 context.Context, p1 address.Address, p2 verifregtypes9.AllocationId, p3 types.TipSetKey) (*verifregtypes9.Allocation, error) {
	if s.Internal.StateGetAllocation == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.StateGetAllocation(p0, p1, p2, p3)
}

func (s *DaemonStub) StateGetAllocation(p0 context.Context, p1 address.Address, p2 verifregtypes9.AllocationId, p3 types.TipSetKey) (*verifregtypes9.Allocation, error) {
	return nil, ErrNotSupported
}

func (s *DaemonStruct) StateGetAllocationForPendingDeal(p0 context.Context, p1 abi.DealID, p2 types.TipSetKey) (*verifregtypes9.Allocation, error) {
	if s.Internal.StateGetAllocationForPendingDeal == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.StateGetAllocationForPendingDeal(p0, p1, p2)
}

func (s *DaemonStub) StateGetAllocationForPendingDeal(p0 context.Context, p1 abi.DealID, p2 types.TipSetKey) (*verifregtypes9.Allocation, error) {
	return nil, ErrNotSupported
}

func (s *DaemonStruct) StateGetAllocationIdForPendingDeal(p0 context.Context, p1 abi.DealID, p2 types.TipSetKey) (verifregtypes9.AllocationId, error) {
	if s.Internal.StateGetAllocationIdForPendingDeal == nil {
		return *new(verifregtypes9.AllocationId), ErrNotSupported
	}
	return s.Internal.StateGetAllocationIdForPendingDeal(p0, p1, p2)
}

func (s *DaemonStub) StateGetAllocationIdForPendingDeal(p0 context.Context, p1 abi.DealID, p2 types.TipSetKey) (verifregtypes9.AllocationId, error) {
	return *new(verifregtypes9.AllocationId), ErrNotSupported
}

func (s *DaemonStruct) StateGetBeaconEntry(p0 context.Context, p1 abi.ChainEpoch) (*types.BeaconEntry, error) {
	if s.Internal.StateGetBeaconEntry == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.StateGetBeaconEntry(p0, p1)
}

func (s *DaemonStub) StateGetBeaconEntry(p0 context.Context, p1 abi.ChainEpoch) (*types.BeaconEntry, error) {
	return nil, ErrNotSupported
}

func (s *DaemonStruct) StateGetRandomnessFromBeacon(p0 context.Context, p1 crypto.DomainSeparationTag, p2 abi.ChainEpoch, p3 []byte, p4 types.TipSetKey) (abi.Randomness, error) {
	if s.Internal.StateGetRandomnessFromBeacon == nil {
		return *new(abi.Randomness), ErrNotSupported
	}
	return s.Internal.StateGetRandomnessFromBeacon(p0, p1, p2, p3, p4)
}

func (s *DaemonStub) StateGetRandomnessFromBeacon(p0 context.Context, p1 crypto.DomainSeparationTag, p2 abi.ChainEpoch, p3 []byte, p4 types.TipSetKey) (abi.Randomness, error) {
	return *new(abi.Randomness), ErrNotSupported
}

func (s *DaemonStruct) StateGetRandomnessFromTickets(p0 context.Context, p1 crypto.DomainSeparationTag, p2 abi.ChainEpoch, p3 []byte, p4 types.TipSetKey) (abi.Randomness, error) {
	if s.Internal.StateGetRandomnessFromTickets == nil {
		return *new(abi.Randomness), ErrNotSupported
	}
	return s.Internal.StateGetRandomnessFromTickets(p0, p1, p2, p3, p4)
}

func (s *DaemonStub) StateGetRandomnessFromTickets(p0 context.Context, p1 crypto.DomainSeparationTag, p2 abi.ChainEpoch, p3 []byte, p4 types.TipSetKey) (abi.Randomness, error) {
	return *new(abi.Randomness), ErrNotSupported
}

func (s *DaemonStruct) StateLookupID(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (address.Address, error) {
	if s.Internal.StateLookupID == nil {
		return *new(address.Address), ErrNotSupported
	}
	return s.Internal.StateLookupID(p0, p1, p2)
}

func (s *DaemonStub) StateLookupID(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (address.Address, error) {
	return *new(address.Address), ErrNotSupported
}

func (s *DaemonStruct) StateMinerActiveSectors(p0 context.Context, p1 address.Address, p2 types.TipSetKey) ([]*SectorOnChainInfo, error) {
	if s.Internal.StateMinerActiveSectors == nil {
		return *new([]*SectorOnChainInfo), ErrNotSupported
	}
	return s.Internal.StateMinerActiveSectors(p0, p1, p2)
}

func (s *DaemonStub) StateMinerActiveSectors(p0 context.Context, p1 address.Address, p2 types.TipSetKey) ([]*SectorOnChainInfo, error) {
	return *new([]*SectorOnChainInfo), ErrNotSupported
}

func (s *DaemonStruct) StateMinerAllocated(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*bitfield.BitField, error) {
	if s.Internal.StateMinerAllocated == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.StateMinerAllocated(p0, p1, p2)
}

func (s *DaemonStub) StateMinerAllocated(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*bitfield.BitField, error) {
	return nil, ErrNotSupported
}

func (s *DaemonStruct) StateMinerInfo(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (MinerInfo, error) {
	if s.Internal.StateMinerInfo == nil {
		return *new(MinerInfo), ErrNotSupported
	}
	return s.Internal.StateMinerInfo(p0, p1, p2)
}

func (s *DaemonStub) StateMinerInfo(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (MinerInfo, error) {
	return *new(MinerInfo), ErrNotSupported
}

func (s *DaemonStruct) StateMinerInitialPledgeCollateral(p0 context.Context, p1 address.Address, p2 SectorPreCommitInfo, p3 types.TipSetKey) (big.Int, error) {
	if s.Internal.StateMinerInitialPledgeCollateral == nil {
		return *new(big.Int), ErrNotSupported
	}
	return s.Internal.StateMinerInitialPledgeCollateral(p0, p1, p2, p3)
}

func (s *DaemonStub) StateMinerInitialPledgeCollateral(p0 context.Context, p1 address.Address, p2 SectorPreCommitInfo, p3 types.TipSetKey) (big.Int, error) {
	return *new(big.Int), ErrNotSupported
}

func (s *DaemonStruct) StateMinerPartitions(p0 context.Context, p1 address.Address, p2 uint64, p3 types.TipSetKey) ([]Partition, error) {
	if s.Internal.StateMinerPartitions == nil {
		return *new([]Partition), ErrNotSupported
	}
	return s.Internal.StateMinerPartitions(p0, p1, p2, p3)
}

func (s *DaemonStub) StateMinerPartitions(p0 context.Context, p1 address.Address, p2 uint64, p3 types.TipSetKey) ([]Partition, error) {
	return *new([]Partition), ErrNotSupported
}

func (s *DaemonStruct) StateMinerPreCommitDepositForPower(p0 context.Context, p1 address.Address, p2 SectorPreCommitInfo, p3 types.TipSetKey) (big.Int, error) {
	if s.Internal.StateMinerPreCommitDepositForPower == nil {
		return *new(big.Int), ErrNotSupported
	}
	return s.Internal.StateMinerPreCommitDepositForPower(p0, p1, p2, p3)
}

func (s *DaemonStub) StateMinerPreCommitDepositForPower(p0 context.Context, p1 address.Address, p2 SectorPreCommitInfo, p3 types.TipSetKey) (big.Int, error) {
	return *new(big.Int), ErrNotSupported
}

func (s *DaemonStruct) StateMinerProvingDeadline(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*dline.Info, error) {
	if s.Internal.StateMinerProvingDeadline == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.StateMinerProvingDeadline(p0, p1, p2)
}

func (s *DaemonStub) StateMinerProvingDeadline(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*dline.Info, error) {
	return nil, ErrNotSupported
}

func (s *DaemonStruct) StateMinerSectors(p0 context.Context, p1 address.Address, p2 *bitfield.BitField, p3 types.TipSetKey) ([]*SectorOnChainInfo, error) {
	if s.Internal.StateMinerSectors == nil {
		return *new([]*SectorOnChainInfo), ErrNotSupported
	}
	return s.Internal.StateMinerSectors(p0, p1, p2, p3)
}

func (s *DaemonStub) StateMinerSectors(p0 context.Context, p1 address.Address, p2 *bitfield.BitField, p3 types.TipSetKey) ([]*SectorOnChainInfo, error) {
	return *new([]*SectorOnChainInfo), ErrNotSupported
}

func (s *DaemonStruct) StateNetworkVersion(p0 context.Context, p1 types.TipSetKey) (network.Version, error) {
	if s.Internal.StateNetworkVersion == nil {
		return *new(network.Version), ErrNotSupported
	}
	return s.Internal.StateNetworkVersion(p0, p1)
}

func (s *DaemonStub) StateNetworkVersion(p0 context.Context, p1 types.TipSetKey) (network.Version, error) {
	return *new(network.Version), ErrNotSupported
}

func (s *DaemonStruct) StateSearchMsg(p0 context.Context, p1 types.TipSetKey, p2 cid.Cid, p3 abi.ChainEpoch, p4 bool) (*MsgLookup, error) {
	if s.Internal.StateSearchMsg == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.StateSearchMsg(p0, p1, p2, p3, p4)
}

func (s *DaemonStub) StateSearchMsg(p0 context.Context, p1 types.TipSetKey, p2 cid.Cid, p3 abi.ChainEpoch, p4 bool) (*MsgLookup, error) {
	return nil, ErrNotSupported
}

func (s *DaemonStruct) StateSectorGetInfo(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 types.TipSetKey) (*SectorOnChainInfo, error) {
	if s.Internal.StateSectorGetInfo == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.StateSectorGetInfo(p0, p1, p2, p3)
}

func (s *DaemonStub) StateSectorGetInfo(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 types.TipSetKey) (*SectorOnChainInfo, error) {
	return nil, ErrNotSupported
}

func (s *DaemonStruct) StateSectorPartition(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 types.TipSetKey) (*SectorLocation, error) {
	if s.Internal.StateSectorPartition == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.StateSectorPartition(p0, p1, p2, p3)
}

func (s *DaemonStub) StateSectorPartition(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 types.TipSetKey) (*SectorLocation, error) {
	return nil, ErrNotSupported
}

func (s *DaemonStruct) StateSectorPreCommitInfo(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 types.TipSetKey) (*SectorPreCommitOnChainInfo, error) {
	if s.Internal.StateSectorPreCommitInfo == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.StateSectorPreCommitInfo(p0, p1, p2, p3)
}

func (s *DaemonStub) StateSectorPreCommitInfo(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 types.TipSetKey) (*SectorPreCommitOnChainInfo, error) {
	return nil, ErrNotSupported
}

func (s *DaemonStruct) SyncSubmitBlock(p0 context.Context, p1 *types.BlockMsg) (error) {
	if s.Internal.SyncSubmitBlock == nil {
		return ErrNotSupported
	}
	return s.Internal.SyncSubmitBlock(p0, p1)
}

func (s *DaemonStub) SyncSubmitBlock(p0 context.Context, p1 *types.BlockMsg) (error) {
	return ErrNotSupported
}

func (s *DaemonStruct) WalletBalance(p0 context.Context, p1 address.Address) (big.Int, error) {
	if s.Internal.WalletBalance == nil {
		return *new(big.Int), ErrNotSupported
	}
	return s.Internal.WalletBalance(p0, p1)
}

func (s *DaemonStub) WalletBalance(p0 context.Context, p1 address.Address) (big.Int, error) {
	return *new(big.Int), ErrNotSupported
}

func (s *DaemonStruct) WalletHas(p0 context.Context, p1 address.Address) (bool, error) {
	if s.Internal.WalletHas == nil {
		return false, ErrNotSupported
	}
	return s.Internal.WalletHas(p0, p1)
}

func (s *DaemonStub) WalletHas(p0 context.Context, p1 address.Address) (bool, error) {
	return false, ErrNotSupported
}

func (s *DaemonStruct) WalletSign(p0 context.Context, p1 address.Address, p2 []byte) (*crypto.Signature, error) {
	if s.Internal.WalletSign == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.WalletSign(p0, p1, p2)
}

func (s *DaemonStub) WalletSign(p0 context.Context, p1 address.Address, p2 []byte) (*crypto.Signature, error) {
	return nil, ErrNotSupported
}

func (s *DaemonStruct) WalletSignMessage(p0 context.Context, p1 address.Address, p2 *types.Message) (*types.SignedMessage, error) {
	if s.Internal.WalletSignMessage == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.WalletSignMessage(p0, p1, p2)
}

func (s *DaemonStub) WalletSignMessage(p0 context.Context, p1 address.Address, p2 *types.Message) (*types.SignedMessage, error) {
	return nil, ErrNotSupported
}




func (s *NetStruct) ID(p0 context.Context) (peer.ID, error) {
	if s.Internal.ID == nil {
		return *new(peer.ID), ErrNotSupported
	}
	return s.Internal.ID(p0)
}

func (s *NetStub) ID(p0 context.Context) (peer.ID, error) {
	return *new(peer.ID), ErrNotSupported
}

func (s *NetStruct) NetAddrsListen(p0 context.Context) (peer.AddrInfo, error) {
	if s.Internal.NetAddrsListen == nil {
		return *new(peer.AddrInfo), ErrNotSupported
	}
	return s.Internal.NetAddrsListen(p0)
}

func (s *NetStub) NetAddrsListen(p0 context.Context) (peer.AddrInfo, error) {
	return *new(peer.AddrInfo), ErrNotSupported
}

func (s *NetStruct) NetAgentVersion(p0 context.Context, p1 peer.ID) (string, error) {
	if s.Internal.NetAgentVersion == nil {
		return "", ErrNotSupported
	}
	return s.Internal.NetAgentVersion(p0, p1)
}

func (s *NetStub) NetAgentVersion(p0 context.Context, p1 peer.ID) (string, error) {
	return "", ErrNotSupported
}

func (s *NetStruct) NetAutoNatStatus(p0 context.Context) (NatInfo, error) {
	if s.Internal.NetAutoNatStatus == nil {
		return *new(NatInfo), ErrNotSupported
	}
	return s.Internal.NetAutoNatStatus(p0)
}

func (s *NetStub) NetAutoNatStatus(p0 context.Context) (NatInfo, error) {
	return *new(NatInfo), ErrNotSupported
}

func (s *NetStruct) NetBandwidthStats(p0 context.Context) (metrics.Stats, error) {
	if s.Internal.NetBandwidthStats == nil {
		return *new(metrics.Stats), ErrNotSupported
	}
	return s.Internal.NetBandwidthStats(p0)
}

func (s *NetStub) NetBandwidthStats(p0 context.Context) (metrics.Stats, error) {
	return *new(metrics.Stats), ErrNotSupported
}

func (s *NetStruct) NetBandwidthStatsByPeer(p0 context.Context) (map[string]metrics.Stats, error) {
	if s.Internal.NetBandwidthStatsByPeer == nil {
		return *new(map[string]metrics.Stats), ErrNotSupported
	}
	return s.Internal.NetBandwidthStatsByPeer(p0)
}

func (s *NetStub) NetBandwidthStatsByPeer(p0 context.Context) (map[string]metrics.Stats, error) {
	return *new(map[string]metrics.Stats), ErrNotSupported
}

func (s *NetStruct) NetBandwidthStatsByProtocol(p0 context.Context) (map[protocol.ID]metrics.Stats, error) {
	if s.Internal.NetBandwidthStatsByProtocol == nil {
		return *new(map[protocol.ID]metrics.Stats), ErrNotSupported
	}
	return s.Internal.NetBandwidthStatsByProtocol(p0)
}

func (s *NetStub) NetBandwidthStatsByProtocol(p0 context.Context) (map[protocol.ID]metrics.Stats, error) {
	return *new(map[protocol.ID]metrics.Stats), ErrNotSupported
}

func (s *NetStruct) NetBlockAdd(p0 context.Context, p1 NetBlockList) (error) {
	if s.Internal.NetBlockAdd == nil {
		return ErrNotSupported
	}
	return s.Internal.NetBlockAdd(p0, p1)
}

func (s *NetStub) NetBlockAdd(p0 context.Context, p1 NetBlockList) (error) {
	return ErrNotSupported
}

func (s *NetStruct) NetBlockList(p0 context.Context) (NetBlockList, error) {
	if s.Internal.NetBlockList == nil {
		return *new(NetBlockList), ErrNotSupported
	}
	return s.Internal.NetBlockList(p0)
}

func (s *NetStub) NetBlockList(p0 context.Context) (NetBlockList, error) {
	return *new(NetBlockList), ErrNotSupported
}

func (s *NetStruct) NetBlockRemove(p0 context.Context, p1 NetBlockList) (error) {
	if s.Internal.NetBlockRemove == nil {
		return ErrNotSupported
	}
	return s.Internal.NetBlockRemove(p0, p1)
}

func (s *NetStub) NetBlockRemove(p0 context.Context, p1 NetBlockList) (error) {
	return ErrNotSupported
}

func (s *NetStruct) NetConnect(p0 context.Context, p1 peer.AddrInfo) (error) {
	if s.Internal.NetConnect == nil {
		return ErrNotSupported
	}
	return s.Internal.NetConnect(p0, p1)
}

func (s *NetStub) NetConnect(p0 context.Context, p1 peer.AddrInfo) (error) {
	return ErrNotSupported
}

func (s *NetStruct) NetConnectedness(p0 context.Context, p1 peer.ID) (p2pnetwork.Connectedness, error) {
	if s.Internal.NetConnectedness == nil {
		return *new(p2pnetwork.Connectedness), ErrNotSupported
	}
	return s.Internal.NetConnectedness(p0, p1)
}

func (s *NetStub) NetConnectedness(p0 context.Context, p1 peer.ID) (p2pnetwork.Connectedness, error) {
	return *new(p2pnetwork.Connectedness), ErrNotSupported
}

func (s *NetStruct) NetDisconnect(p0 context.Context, p1 peer.ID) (error) {
	if s.Internal.NetDisconnect == nil {
		return ErrNotSupported
	}
	return s.Internal.NetDisconnect(p0, p1)
}

func (s *NetStub) NetDisconnect(p0 context.Context, p1 peer.ID) (error) {
	return ErrNotSupported
}

func (s *NetStruct) NetFindPeer(p0 context.Context, p1 peer.ID) (peer.AddrInfo, error) {
	if s.Internal.NetFindPeer == nil {
		return *new(peer.AddrInfo), ErrNotSupported
	}
	return s.Internal.NetFindPeer(p0, p1)
}

func (s *NetStub) NetFindPeer(p0 context.Context, p1 peer.ID) (peer.AddrInfo, error) {
	return *new(peer.AddrInfo), ErrNotSupported
}

func (s *NetStruct) NetLimit(p0 context.Context, p1 string) (NetLimit, error) {
	if s.Internal.NetLimit == nil {
		return *new(NetLimit), ErrNotSupported
	}
	return s.Internal.NetLimit(p0, p1)
}

func (s *NetStub) NetLimit(p0 context.Context, p1 string) (NetLimit, error) {
	return *new(NetLimit), ErrNotSupported
}

func (s *NetStruct) NetPeerInfo(p0 context.Context, p1 peer.ID) (*ExtendedPeerInfo, error) {
	if s.Internal.NetPeerInfo == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.NetPeerInfo(p0, p1)
}

func (s *NetStub) NetPeerInfo(p0 context.Context, p1 peer.ID) (*ExtendedPeerInfo, error) {
	return nil, ErrNotSupported
}

func (s *NetStruct) NetPeers(p0 context.Context) ([]peer.AddrInfo, error) {
	if s.Internal.NetPeers == nil {
		return *new([]peer.AddrInfo), ErrNotSupported
	}
	return s.Internal.NetPeers(p0)
}

func (s *NetStub) NetPeers(p0 context.Context) ([]peer.AddrInfo, error) {
	return *new([]peer.AddrInfo), ErrNotSupported
}

func (s *NetStruct) NetPing(p0 context.Context, p1 peer.ID) (time.Duration, error) {
	if s.Internal.NetPing == nil {
		return *new(time.Duration), ErrNotSupported
	}
	return s.Internal.NetPing(p0, p1)
}

func (s *NetStub) NetPing(p0 context.Context, p1 peer.ID) (time.Duration, error) {
	return *new(time.Duration), ErrNotSupported
}

func (s *NetStruct) NetProtectAdd(p0 context.Context, p1 []peer.ID) (error) {
	if s.Internal.NetProtectAdd == nil {
		return ErrNotSupported
	}
	return s.Internal.NetProtectAdd(p0, p1)
}

func (s *NetStub) NetProtectAdd(p0 context.Context, p1 []peer.ID) (error) {
	return ErrNotSupported
}

func (s *NetStruct) NetProtectList(p0 context.Context) ([]peer.ID, error) {
	if s.Internal.NetProtectList == nil {
		return *new([]peer.ID), ErrNotSupported
	}
	return s.Internal.NetProtectList(p0)
}

func (s *NetStub) NetProtectList(p0 context.Context) ([]peer.ID, error) {
	return *new([]peer.ID), ErrNotSupported
}

func (s *NetStruct) NetProtectRemove(p0 context.Context, p1 []peer.ID) (error) {
	if s.Internal.NetProtectRemove == nil {
		return ErrNotSupported
	}
	return s.Internal.NetProtectRemove(p0, p1)
}

func (s *NetStub) NetProtectRemove(p0 context.Context, p1 []peer.ID) (error) {
	return ErrNotSupported
}

func (s *NetStruct) NetPubsubScores(p0 context.Context) ([]PubsubScore, error) {
	if s.Internal.NetPubsubScores == nil {
		return *new([]PubsubScore), ErrNotSupported
	}
	return s.Internal.NetPubsubScores(p0)
}

func (s *NetStub) NetPubsubScores(p0 context.Context) ([]PubsubScore, error) {
	return *new([]PubsubScore), ErrNotSupported
}

func (s *NetStruct) NetSetLimit(p0 context.Context, p1 string, p2 NetLimit) (error) {
	if s.Internal.NetSetLimit == nil {
		return ErrNotSupported
	}
	return s.Internal.NetSetLimit(p0, p1, p2)
}

func (s *NetStub) NetSetLimit(p0 context.Context, p1 string, p2 NetLimit) (error) {
	return ErrNotSupported
}

func (s *NetStruct) NetStat(p0 context.Context, p1 string) (NetStat, error) {
	if s.Internal.NetStat == nil {
		return *new(NetStat), ErrNotSupported
	}
	return s.Internal.NetStat(p0, p1)
}

func (s *NetStub) NetStat(p0 context.Context, p1 string) (NetStat, error) {
	return *new(NetStat), ErrNotSupported
}



var _ Common = new(CommonStruct)
var _ Daemon = new(DaemonStruct)
var _ Net = new(NetStruct)


